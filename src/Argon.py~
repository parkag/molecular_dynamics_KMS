from math import sqrt
from copy import deepcopy
import random
from Particle import Particle


class ClosedSystem(object):
    """
    Contains whole world of the simulation
    """
    n = 5
    m = 1.0
    eps = 1.0
    f = 1e4
    L = 1.2
    a = 0.38  # constant, nanometers
    R = 0.38
    T0 = 1000
    tau = 2e-4
    So = 100
    Sd = 2000
    Sout = 10
    Sxyz = 10

    particle_count = n ** 3
    particles = [None] * particle_count

    def __init__(self):
        pass

    def create_particles(self):
        b1 = [self.a, 0.0, 0.0]  # basis vectors
        b2 = [self.a / 2.0, self.a * sqrt(3.0) / 2.0, 0.0]
        b3 = [self.a / 2.0, self.a * sqrt(3.0) / 6.0, self.a * sqrt(2.0 / 3.0)]

        curr_ind = 0
        for i in xrange(self.n):
            i_part = (i - (self.n - 1) / 2.0)
            for j in xrange(self.n):
                j_part = (j - (self.n - 1) / 2.0)
                for k in xrange(self.n):
                    k_part = (k - (self.n - 1) / 2.0)

                    self.particles[curr_ind] = Particle()
                    self.particles[curr_ind].r = [0,0,0] #nie rozumiem czemu tego potrzebuje
                    for d in xrange(3):
                        self.particles[curr_ind].r[d] = (i_part * b1[d] + j_part * b2[d] + k_part * b3[d])
                        self.particles[curr_ind].p[d] = random.uniform(-1, 1)

                    curr_ind += 1

    def calculate_state(self):
        V = 0.0
        Vs = [None] * self.particle_count
        Vp = [None] * self.particle_count
        P = 0.0
        ri = 0
        for i in xrange(self.particle_count):
            #(10) potencjaly od scianek do V
            ri = self.particles[i].abs_r()
            if ri >= self.L:
                Vs[i] = 0.5 * self.f * (ri - self.L) ** 2
            else:
                Vs[i] = 0.0

            #(14) sily odpychania od scianek do Fi
            if ri >= self.L:
                for d in xrange(3):
                    self.particles[i].F[d] = self.f * (self.L - ri) * self.particles[i].r[d] / ri
            else:
                for d in xrange(3):
                    self.particles[i].F[d] = 0.0

            #(15) akumulacja cisnienia chwilowego
            P += 1/(4*3.1415 * self.L**2) * self.particles[i].abs_F()
	    """
            for j in xrange(i-1):
		if (i != j):
                	rij = sqrt( (self.particles[j].r[0] - self.particles[i].r[0])**2 + (self.particles[j].r[1] - self.particles[i].r[1])**2 + (self.particles[j].r[2] - self.particles[i].r[2])**2)
			print "rij =", rij                	
			#potencjaly par atomowych (9) i akumulacja do V (11)
                	V += self.eps*( (self.R/rij) ** 12 - 2*(self.R/rij)**6)
                	#sily miedzyatomowe(13) do Fi, Fj, pamietajac ze (Fpji = - Fpij)
                	for d in xrange(3):
                    		self.particles[i].F[d] += 12 * self.eps * ( ( self.R/rij ) ** 12 - (self.R / rij ) ** 6 ) * (self.particles[i].r[d] - self.particles[j].r[d]) / rij**2

            V += Vs[i]
        #print 'V=', V
	"""
    def evolve(self):
        #for s in xrange(self.So + self.Sd):
        for s in xrange(1):
            #modyfikacja pedow (18a)
            for i in xrange(self.particle_count):
                for d in xrange(3):
                    self.particles[i].p[d] += 0.5 * self.particles[i].F[d] * self.tau
             #modyfikacja polozen (18b)
                    self.particles[i].r[d] += self.tau/self.m * self.particles[i].p[d]
            #obliczenie nowego potencjalu, sil, chwilowego cisnienia (alg2)
            self.calculate_state()
            for i in xrange(self.particle_count):
                for d in xrange(3):
            #modyfikacja pedow (18c)
                    self.particles[i].p[d] += 0.5 * self.particles[i].F[d] * self.tau
            #obliczenie T (19), E (16)
            if ( s % self.Sout == 0 ):
                #zapis t, H, V, T, P do pliku
                pass
            if ( s % self.Sxyz == 0 ):
                #zapis r[][], E[] do avs.dat (x,y,z,E)
                pass
            if ( s > self.So ):
                #akumulacja wartosci usrednianych T', P', H'
                pass

def main():
    system = ClosedSystem()
    system.create_particles()

    for particle in system.particles:
        print particle.r[0], particle.r[1], particle.r[2]

    system.calculate_state()
    for i in xrange(100):
        system.evolve()
        for particle in system.particles:
            print particle.r[0], particle.r[1], particle.r[2]


if __name__ == "__main__":
    main()
